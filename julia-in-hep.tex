% This paper is Copyright Â© Graeme Andrew Stewart, Sam Skipsey, 
% authors, 2025.
% Licensed under Creative Commons Attribution 4.0 International (CC BY 4.0), see LICENSE

\documentclass{webofc}
\usepackage{graphicx} % Required for inserting images
\graphicspath{{figures/}}
\usepackage{subcaption}
\usepackage[varg]{txfonts}
\usepackage[utf8]{inputenc}

% Workaround for arXiv, start with "finalizecache" then switch to "frozencache"
\usepackage[finalizecache,cachedir=.]{minted}
% \usepackage[frozencache,cachedir=.]{minted}

\usepackage{natbib}
\usepackage{hyperref}
\usepackage{enumitem}

% For draft version
\usepackage{lineno}
\linenumbers

\newcommand{\unroot}{\texttt{UnROOT.jl}}

\newcommand{\kt}{${k}_\text{T}$}
\newcommand{\akt}{anti-${k}_\text{T}$}
\newcommand{\Akt}{Anti-${k}_\text{T}$}
\newcommand{\JR}{\texttt{JetReconstruction.jl}}
\newcommand{\ee}{$e^+e^-$}

\title{Julia in HEP}

\author{\firstname{Graeme Andrew} \lastname{Stewart}\inst{1}\fnsep\thanks{\email{graeme.andrew.stewart@cern.ch}} \and
\firstname{Sam} \lastname{Skipsey}\inst{2}
% etc.
}

\institute{CERN, Esplanade des Particules 1, Geneva, Switzerland
\and
School of Physics \& Astronomy, University of Glasgow, Glasgow, United Kingdom, G12 8QQ}


\abstract{%
Julia is a mature general-purpose programming language, with a large ecosystem
of libraries and more than 10000 third-party packages, which specifically
targets scientific computing. As a language, Julia is as dynamic, interactive,
and accessible as Python with NumPy, but achieves run-time performance on par
with C/C++. In this paper, we describe the state of adoption of Julia in HEP,
where momentum has been gathering over a number of years.

HEP-oriented Julia packages can, via \texttt{UnROOT.jl}, already read HEP's
major file formats, including TTree and RNTuple formats. Interfaces to some of
HEP's major software packages, such as through \texttt{Geant4.jl}, are available
too. Jet reconstruction algorithms in Julia show excellent performance. A number
of full HEP analyses have been performed in Julia.

We show how, as the support for HEP has matured, developments have benefited
from Julia's core design choices, which makes reuse from and integration with
other packages easy. In particular, libraries developed outside HEP for
plotting, statistics, fitting, and scientific machine learning are extremely
useful.

We believe that the powerful combination of flexibility and speed, the wide
selection of scientific programming tools, and support for all modern
programming paradigms and tools, make Julia the ideal choice for a future
language in HEP.}

\begin{document}

\maketitle

\section{Programming Languages in High Energy Physics}
\label{sec:introduction}

\subsection{HEP Needs}

What do we need from code? Some desiderata.

\subsection{From Fortran to the C++/Python Era}

A bit of history from~\cite{pivarski2022}.

The situation today. Some thoughts on tradeoffs.

\section{Julia}

\subsection{Julia's Motivations}

Some of the design goals of the language. \emph{Julia Programming
Language}~\cite{bib:julia_freshapproach,10.1145/3276490}

The Julia programming language was announced formally to the world in 2012 with a blog post entitled "Why We Created Julia"\cite{bib:why-create-julia}.
This document lists a series of ambitious goals for the language, and represents a view into the core developers' mindset, supplemented by the follow-up 
community-contributed article "Why We Use Julia, 10 Years Later"\cite{bib:why-julia-10}. 

Julia's design attempts to provide a syntax as productive as Python, especially for numerical work, whilst leveraging JAOT\footnote{Just-Ahead-Of-Time} compilation to provide execution times
on the order of those of compiled, statically typed languages like C and Rust. It utilises type inference - like that added post-hoc to C++, and as present in other 
modern language by default - to allow the programmer add as much, or as little, detailed constraint to a program as they need. Like MatLab and Fortran,
Julia's native operations and type system support arrays as first-class entities, of any dimension, allowing array-oriented code to be both
productively generated, and efficiently executed, with operations naturally "broadcasted" element- or dimension-wise. 

%Design goals and aims
%Open source
%Speed like C, but dynamic like Ruby/Python
%Obvious mathematical notation
%General purpose like Python
%As easy for statistics as R
%Powerful linear algebra like in Matlab
%Good for gluing programs together like the shell


\subsection{Julia in Practice}

Some code examples - demonstrate \emph{ease} and also give some benchmarks for
speed.



%Tooling and ecosystem.
As with other languages of the 2010s, Julia comes with a set of tools for managing development environments beyond the interpreter.

`juliaup` allows seamless management of multiple Julia releases on the same machine, including tracking particular patch releases, and 
choosing the system default.

The integrated package management in Julia - via the Pkg library, or a sub-environment within a Julia REPL accessed by pressing '$]$', 
tracks and maintains the dependency graph of a Julia project. State is entirely stored within two human-readable files - Manifest.toml and Project.toml
. The user of a Julia codebase can easily reproduce the exact environment needed for the codebase, to the level of dependencies of 
dependencies of packages, by simply using the "instantiate" command as long as the Project.toml file is provided.
The Julia Package "General Registry" indexes packages and their releases, and (as with other languages such as Rust and Javascript) relies on a public
index hosted on GitHub (with off-GitHub backups).

Leveraging the fact that Julia is JAOT-compiled, and that this allows its entire standard library to be written in idiomatic Julia, the REPL also provides
a series of powerful macro utilities for inspecting the byte- and machine-code generated for a given expression (\verb$@code_lowered$, \verb$@code_native$) and
for locating and displaying the source code for any function in the current namespace, including from the standard library (\verb$@less$), as well as other introspection
tools.
A help environment, accessed by "?" on an empty line of the REPL, allows interactive help on any keyword or symbol known to the REPL's current state. This relies 
on docstrings, but extended introspection tools are also available in optional packages (such as \texttt{About.jl}, which can provide information 
on memory layout of datatypes and thread safety of functions).

\subsection{Key Design Features for Performance}

Type system.

Multiple dispatch.

\section{Julia for Scientific Computing}

General adoption:~\cite{perkel-julia-science}.

GPU programming.

Some HPC codes.

\section{Julia in HEP}

\subsection{Challenges}

What does HEP need from its computing?

Cite some general overviews:~\cite{Stanitzki:2020bnx,eschle2023potential}.

\subsection{HEP Data Formats}

We can read that data... UpROOT.jl. EDM4hep.jl.

\subsection{Event Generators}

A bit about QuantumElectrodynamics.jl.

\subsection{Simulation}

Overview of Geant4.jl.

\subsection{Reconstruction}

JetReconstruction.jl

\subsection{Analysis}

Overview of analysis papers and suitability of Julia.

\subsection{End-to-end Computing}

The Legend Julia stack.

\section{Conclusions}

It's all good, nothing can go wrong. To infinity and beyond, etc.

\sloppy
\raggedright
% \clearpage
\bibliography{julia-in-hep}

\end{document}
